#!/usr/bin/env python3
"""Reword step for the gai refresh_cl_desc workflow."""

import re
import subprocess
import sys
from pathlib import Path

# Add gai source directory to path for imports
_GAI_SRC = Path.home() / "lib" / "gai" / "src"
if str(_GAI_SRC) not in sys.path:
    sys.path.insert(0, str(_GAI_SRC))


def escape_for_hg_reword(desc: str) -> str:
    """Escape a description string for passing to bb_hg_reword."""
    return (
        desc.replace("\\", "\\\\")
        .replace("'", "\\'")
        .replace("\n", "\\n")
        .replace("\t", "\\t")
        .replace("\r", "\\r")
    )


def _sync_description_to_project_file(
    project_file: str, cl_name: str
) -> None:
    """Sync the ChangeSpec DESCRIPTION field after a successful reword.

    Runs ``cl_desc -s`` to get the clean description and writes it back to
    the ``.gp`` project file.  Errors are non-fatal (warnings only) since
    the reword itself already succeeded.
    """
    from status_state_machine import update_changespec_description_atomic

    try:
        desc_result = subprocess.run(
            ["cl_desc", "-s"],
            capture_output=True,
            text=True,
            check=True,
        )
    except (subprocess.CalledProcessError, FileNotFoundError) as e:
        print(
            f"Warning: could not read updated description: {e}",
            file=sys.stderr,
        )
        return

    new_description = desc_result.stdout.strip()
    if not new_description:
        print(
            "Warning: cl_desc -s returned empty output, "
            "skipping DESCRIPTION sync",
            file=sys.stderr,
        )
        return

    success = update_changespec_description_atomic(
        project_file, cl_name, new_description
    )
    if success:
        print("Synced DESCRIPTION to project file")
    else:
        print(
            "Warning: failed to sync DESCRIPTION to project file",
            file=sys.stderr,
        )


def main() -> None:
    """Run the reword step for refresh_cl_desc workflow."""
    desc_file = sys.argv[1]
    cl_name = sys.argv[2] if len(sys.argv) > 2 else ""
    project_file = sys.argv[3] if len(sys.argv) > 3 else ""

    # Read AI-generated description
    with open(desc_file) as f:
        new_desc = f.read().strip()

    # Get current full description to preserve metadata tags
    result = subprocess.run(
        ["cl_desc"], capture_output=True, text=True, check=True
    )
    current_full = result.stdout.rstrip("\n")

    # Extract project prefix (e.g., "yserve" from "[yserve] ...")
    project_match = re.match(r"^\[([^\]]+)\]", current_full)
    project = project_match.group(1) if project_match else None

    # Extract metadata tag block from end of current description
    lines = current_full.split("\n")
    tag_pattern = re.compile(r"^[A-Z][A-Za-z_\s-]*[=:]")

    # Skip trailing blank lines
    last_non_blank = len(lines) - 1
    while last_non_blank >= 0 and lines[last_non_blank].strip() == "":
        last_non_blank -= 1

    # Scan upward to find contiguous tag block
    tags_start = len(lines)
    for i in range(last_non_blank, -1, -1):
        if tag_pattern.match(lines[i].strip()):
            tags_start = i
        else:
            break

    tag_block = (
        "\n".join(lines[tags_start:]) if tags_start < len(lines) else ""
    )

    # Prepend project prefix
    if project:
        new_desc = f"[{project}] {new_desc}"

    # Combine new description with original metadata tags
    full_desc = (
        (new_desc + "\n\n<!-- prettier-ignore -->\n" + tag_block)
        if tag_block
        else new_desc
    )

    escaped = escape_for_hg_reword(full_desc)
    subprocess.run(["bb_hg_reword", escaped], check=True)

    # Sync DESCRIPTION field in .gp project file
    if cl_name and project_file:
        _sync_description_to_project_file(project_file, cl_name)

    print("success=true")


if __name__ == "__main__":
    main()
