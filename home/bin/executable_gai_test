#!/bin/bash

source ~/lib/bugyi.sh

export TZ=America/New_York
export USAGE_GRAMMAR=(
  "[-v] [-f|--force] GAI_DIRECTORY AGENT_NAME"
  "-h"
)

read -r -d '' DOC <<EOM
$(usage)

Manages test execution for GAI workflows.

Positional Arguments
--------------------
GAI_DIRECTORY
    Relative gai workflow directory path (e.g., bb/gai/20251023165555).

AGENT_NAME
    Unique identifier for the agent running the test.

Optional Arguments
------------------
-f | --force
    Bypass test run limit (allows unlimited test runs).

-h | --help
    View this help message.

-v | --verbose
    Enable verbose output. This option can be specified multiple times (e.g. -v, -vv, ...).

Description
-----------
This script manages test execution for GAI workflows by:
  - Saving test output and diffs to files
  - Preventing duplicate test runs by comparing diffs
  - Limiting the number of test runs per agent (unless --force is used)
  - Trimming test output similar to the fix-test workflow

Examples
--------
gai_test bb/gai/20251023165555 agent_1
gai_test --force bb/gai/20251023165555 fix-test
EOM

# NOTE: This MUST come after the `read -r -d''` line above!
set -e

function run() {
  parse_cli_args "$@"

  # Validate that GAI_DIRECTORY exists
  if [[ ! -d "$GAI_DIRECTORY" ]]; then
    die "GAI directory '%s' does not exist" "$GAI_DIRECTORY"
  fi

  main_logic
}

function parse_cli_args() {
  log::debug "Command-Line Arguments: ($*)"

  eval set -- "$(getopt -o "f,h,v" -l "force,help,verbose" -- "$@")"

  VERBOSE=0
  FORCE_MODE=false
  while [[ -n "$1" ]]; do
    case $1 in
    -f | --force)
      FORCE_MODE=true
      ;;
    -h | --help)
      echo "${DOC}"
      exit 0
      ;;
    -v | --verbose)
      VERBOSE=$((VERBOSE + 1))
      ;;
    --)
      shift
      break
      ;;
    esac
    shift
  done

  if [[ "${VERBOSE}" -gt 1 ]]; then
    PS4='$LINENO: '
    set -x
  fi

  if [[ $# -ne 2 ]]; then
    die "$(usage)" 2
  fi

  readonly GAI_DIRECTORY="$1"
  readonly AGENT_NAME="$2"
  readonly DOC
  readonly VERBOSE
  readonly FORCE_MODE
}

function extract_test_command() {
  # Read the test command from the first test output file in the directory
  local test_command=""
  for file in "$GAI_DIRECTORY"/test_output*.txt; do
    if [[ -f "$file" ]]; then
      # Extract test command from the first line (remove first word prefix)
      test_command=$(head -n 1 "$file" | cut -d' ' -f2-)
      break
    fi
  done

  if [[ -z "$test_command" ]]; then
    die "Could not find test command in GAI directory"
  fi

  log::info "Test command: %s" "$test_command"
  echo "$test_command"
}

function check_test_limits() {
  local test_command="$1"

  # Check test run limits
  local test_runs_limit_file="$GAI_DIRECTORY/test_runs_limit.txt"
  local agent_test_count_file="$GAI_DIRECTORY/agent_test_counts.txt"

  # Default limit is 1 if not specified
  local test_runs_limit=1
  if [[ -f "$test_runs_limit_file" ]]; then
    test_runs_limit=$(cat "$test_runs_limit_file")
  fi

  # Check current test count for this agent (skip if force mode is enabled)
  local current_count=0
  if [[ -f "$agent_test_count_file" ]]; then
    current_count=$(grep "^$AGENT_NAME:" "$agent_test_count_file" 2>/dev/null | cut -d: -f2 || echo 0)
  fi

  if [[ "$FORCE_MODE" == "false" && $current_count -ge $test_runs_limit ]]; then
    die "Agent '%s' has already reached the test run limit of %d\nUse --force flag to bypass this limit" "$AGENT_NAME" "$test_runs_limit"
  fi

  # Return values for use by other functions
  echo "$test_runs_limit:$current_count:$agent_test_count_file"
}

function check_duplicate_diff() {
  # Generate current diff
  local current_diff=$(hg diff)
  local current_diff_hash=$(echo "$current_diff" | sha256sum | cut -d' ' -f1)

  # Check if this diff has been tested before
  local diff_history_dir="$GAI_DIRECTORY/test_diffs"
  mkdir -p "$diff_history_dir"

  # Look for existing diff with same hash
  local existing_diff_file=""
  for diff_file in "$diff_history_dir"/*.diff; do
    if [[ -f "$diff_file" ]]; then
      local existing_hash=$(sha256sum "$diff_file" | cut -d' ' -f1)
      if [[ "$existing_hash" == "$current_diff_hash" ]]; then
        existing_diff_file="$diff_file"
        break
      fi
    fi
  done

  if [[ -n "$existing_diff_file" ]]; then
    handle_duplicate_diff "$existing_diff_file"
    # This function will exit, so we never return from here
  fi

  # Return values for use by other functions
  echo "$current_diff:$diff_history_dir"
}

function handle_duplicate_diff() {
  local existing_diff_file="$1"

  # This diff has been tested before
  log::info "This exact code change has already been tested."
  log::info "Previous diff file: %s" "$existing_diff_file"

  # Find and display the previous test output
  local diff_basename=$(basename "$existing_diff_file" .diff)
  local previous_output_file="$GAI_DIRECTORY/${diff_basename}_output.txt"
  local previous_exit_code_file="$GAI_DIRECTORY/${diff_basename}_exit_code.txt"

  if [[ -f "$previous_output_file" ]]; then
    echo ""
    echo "Previous test output:"
    echo "===================="
    cat "$previous_output_file"
  else
    log::warn "Could not find previous test output file: %s" "$previous_output_file"
  fi

  # Determine the exit code from the previous test run
  local previous_exit_code=0
  if [[ -f "$previous_exit_code_file" ]]; then
    previous_exit_code=$(cat "$previous_exit_code_file")
  else
    # Fallback: try to determine from the output if test passed or failed
    if [[ -f "$previous_output_file" ]]; then
      # If output contains failure indicators, assume it failed
      if grep -q -E "(FAILED|ERROR|There was [0-9]+ failure|Test failed)" "$previous_output_file"; then
        previous_exit_code=1
      fi
    fi
  fi

  echo ""
  if [[ $previous_exit_code -eq 0 ]]; then
    log::info "Previous test: PASSED"
  else
    log::info "Previous test: FAILED"
  fi

  exit "$previous_exit_code"
}

function run_test_and_save_output() {
  local test_command="$1"
  local current_diff="$2"
  local diff_history_dir="$3"
  local current_count="$4"
  local test_runs_limit="$5"
  local agent_test_count_file="$6"

  # Create unique filenames for this test run
  local timestamp=$(date +%Y%m%d%H%M%S)
  local diff_file="$diff_history_dir/${AGENT_NAME}_${timestamp}.diff"
  local output_file="$GAI_DIRECTORY/${AGENT_NAME}_${timestamp}_output.txt"
  local exit_code_file="$GAI_DIRECTORY/${AGENT_NAME}_${timestamp}_exit_code.txt"

  # Save the current diff
  echo "$current_diff" >"$diff_file"

  # Update agent test count
  local new_count=$((current_count + 1))
  if [[ -f "$agent_test_count_file" ]]; then
    # Remove existing entry for this agent and add new one
    grep -v "^$AGENT_NAME:" "$agent_test_count_file" >"${agent_test_count_file}.tmp" || true
    echo "$AGENT_NAME:$new_count" >>"${agent_test_count_file}.tmp"
    mv "${agent_test_count_file}.tmp" "$agent_test_count_file"
  else
    echo "$AGENT_NAME:$new_count" >"$agent_test_count_file"
  fi

  if [[ "$FORCE_MODE" == "true" ]]; then
    log::info "Running test (attempt %d, force mode enabled - no limit)..." "$new_count"
  else
    log::info "Running test (attempt %d of %d)..." "$new_count" "$test_runs_limit"
  fi

  # Run the test command and capture output
  local test_output
  local return_code
  if test_output=$(eval "$test_command" 2>&1); then
    return_code=0
  else
    return_code=$?
  fi

  # Apply the same trimming logic as the fix-test workflow
  local trimmed_output="$test_output"

  # Check if "There was 1 failure" exists in the output
  if echo "$test_output" | grep -q "There was 1 failure"; then
    # Use the same trimming logic: tac | grep -m1 'There was 1 failure' -B1000 | tac
    trimmed_output=$(echo "$test_output" | tac | grep -m1 "There was 1 failure" -B1000 | tac)
  fi

  # Save the trimmed output to file
  echo "$trimmed_output" >"$output_file"

  # Save the exit code to file
  echo "$return_code" >"$exit_code_file"

  # Display the output
  echo ""
  echo "Test output (saved to $output_file):"
  echo "===================================="
  echo "$trimmed_output"

  # Exit with the same code as the test command
  exit $return_code
}

function main_logic() {
  local test_command
  test_command=$(extract_test_command)

  local limits_info
  limits_info=$(check_test_limits "$test_command")
  local test_runs_limit=$(echo "$limits_info" | cut -d: -f1)
  local current_count=$(echo "$limits_info" | cut -d: -f2)
  local agent_test_count_file=$(echo "$limits_info" | cut -d: -f3)

  local diff_info
  diff_info=$(check_duplicate_diff)
  local current_diff=$(echo "$diff_info" | cut -d: -f1)
  local diff_history_dir=$(echo "$diff_info" | cut -d: -f2-)

  run_test_and_save_output "$test_command" "$current_diff" "$diff_history_dir" "$current_count" "$test_runs_limit" "$agent_test_count_file"
}

if [[ "${SCRIPTNAME}" == "$(basename "${BASH_SOURCE[0]}")" ]]; then
  run "$@"
fi
