#!/usr/bin/env python3
"""Find unused public Python function and class definitions."""

import argparse
import ast
import re
import sys
from pathlib import Path


def find_python_files(directory: Path, exclude_test_dirs: bool = True) -> list[Path]:
    """Find all .py files in directory, optionally excluding test directories."""
    exclude_patterns = {"test", "tests", ".venv", "venv"} if exclude_test_dirs else set()

    python_files = []
    for py_file in directory.rglob("*.py"):
        # Check if any parent directory is in exclude_patterns
        if any(part in exclude_patterns for part in py_file.parts):
            continue
        python_files.append(py_file)

    return python_files


def extract_public_functions(file_path: Path) -> list[str]:
    """Extract all public top-level function and class names from a Python file."""
    try:
        with open(file_path, encoding="utf-8") as f:
            tree = ast.parse(f.read(), filename=str(file_path))

        symbols = []
        # Only iterate over module-level nodes, not nested functions/methods
        for node in tree.body:
            if isinstance(node, (ast.FunctionDef, ast.ClassDef)):
                # Only public symbols (not prefixed with _)
                if not node.name.startswith("_"):
                    symbols.append(node.name)

        return symbols
    except (SyntaxError, UnicodeDecodeError) as e:
        print(f"Warning: Could not parse {file_path}: {e}", file=sys.stderr)
        return []


def search_function_usage(function_name: str, search_files: list[Path]) -> bool:
    r"""Search for usage of a function or class in the given files.

    Uses two patterns:
    1. ^\s\s\s\s<symbol>,     - Symbol in a list with 4-space indentation
    2. from\s.*\simport.*\s<symbol> - Import statement
    """
    # Using word boundaries to ensure we match the exact symbol name
    patterns = [
        rf"^\s\s\s\s{re.escape(function_name)},",
        rf"from\s.*\simport.*\s{re.escape(function_name)}\b",
    ]

    for pattern in patterns:
        for file_path in search_files:
            try:
                with open(file_path, encoding="utf-8") as f:
                    content = f.read()
                    if re.search(pattern, content, re.MULTILINE):
                        return True
            except (UnicodeDecodeError, OSError):
                continue

    return False


def main():
    parser = argparse.ArgumentParser(
        description="Find unused public Python function and class definitions"
    )
    parser.add_argument(
        "directory", type=Path, help="Directory to search for Python files"
    )
    args = parser.parse_args()

    if not args.directory.is_dir():
        print(f"Error: {args.directory} is not a directory", file=sys.stderr)
        return 1

    # Find all Python files excluding test directories
    python_files = find_python_files(args.directory)

    if not python_files:
        print("No Python files found", file=sys.stderr)
        return 0

    # Collect all public functions and classes from all files
    all_symbols = {}  # {symbol_name: [file_path, ...]}
    for py_file in python_files:
        symbols = extract_public_functions(py_file)
        for symbol in symbols:
            if symbol not in all_symbols:
                all_symbols[symbol] = []
            all_symbols[symbol].append(py_file)

    if not all_symbols:
        print("No public functions or classes found", file=sys.stderr)
        return 0

    # Search for usage of each symbol
    unused_symbols = []
    for symbol_name, def_files in all_symbols.items():
        if not search_function_usage(symbol_name, python_files):
            unused_symbols.append((symbol_name, def_files))

    # Report results
    if unused_symbols:
        print("Unused public functions and classes:")
        for symbol_name, def_files in sorted(unused_symbols):
            for file_path in def_files:
                print(f"  {symbol_name} in {file_path}")
        return 1

    print("All public functions and classes are used")
    return 0


if __name__ == "__main__":
    sys.exit(main())
