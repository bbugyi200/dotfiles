#!/bin/bash

source ~/lib/bugyi.sh

export USAGE_GRAMMAR=(
  "[-n WORDS] [-s DELAY] [-v]"
  "-h"
)

read -r -d '' DOC <<EOM
$(usage)

Read clipboard contents, split into word-based chunks, and paste each chunk
sequentially into the active application with a small delay. Useful for
applications that struggle with large pastes or have paste-size restrictions.

Optional Arguments
------------------
-h | --help
    View this help message.

-n WORDS | --num-words WORDS
    Number of words per chunk (default: 5).

-s DELAY | --sleep DELAY
    Delay in seconds between pastes (default: 0.1).

-v | --verbose
    Enable verbose output. This option can be specified multiple times (e.g. -v, -vv, ...).
EOM

function run() {
  parse_cli_args "$@"

  local original_clip
  original_clip="$(paste_clip)"

  local total
  total=$(printf '%s' "${original_clip}" | wc -w | tr -d ' ')
  if [[ ${total} -eq 0 ]]; then
    die "Clipboard is empty."
  fi

  log::info "Pasting ${total} words in chunks of ${NUM_WORDS}..."

  # Give user time to focus the target application.
  sleep 1

  # Build a flat token array: words interspersed with newline markers.
  # A newline marker (NL_MRK) is placed between every pair of adjacent lines,
  # including empty lines (which contribute a marker but no words).
  local NL_MRK=$'\x01'
  local -a tokens=()
  local line_idx=0
  while IFS= read -r line || [[ -n "${line}" ]]; do
    if [[ ${line_idx} -gt 0 ]]; then
      tokens+=("${NL_MRK}")
    fi
    if [[ -n "${line}" ]]; then
      local -a line_words
      read -r -a line_words <<<"${line}"
      tokens+=("${line_words[@]}")
    fi
    line_idx=$((line_idx + 1))
  done <<<"${original_clip}"

  # Paste tokens in chunks of NUM_WORDS words.
  # Newline markers don't count toward the word limit.
  # After each chunk, if the next token is a newline marker, pull it (and
  # consecutive markers plus one following word) into the current chunk so
  # that newlines are always embedded between content.
  local i=0
  local num_tokens=${#tokens[@]}
  local chunk_num=0

  while [[ ${i} -lt ${num_tokens} ]]; do
    local chunk=""
    local word_count=0
    chunk_num=$((chunk_num + 1))

    # Build chunk up to NUM_WORDS words.
    while [[ ${i} -lt ${num_tokens} ]] && [[ ${word_count} -lt ${NUM_WORDS} ]]; do
      if [[ "${tokens[i]}" == "${NL_MRK}" ]]; then
        chunk+=$'\n'
        i=$((i + 1))
      else
        if [[ -n "${chunk}" ]] && [[ "${chunk: -1}" != $'\n' ]]; then
          chunk+=" "
        fi
        chunk+="${tokens[i]}"
        word_count=$((word_count + 1))
        i=$((i + 1))
      fi
    done

    # Pull trailing newline markers + one word to keep newlines embedded.
    while [[ ${i} -lt ${num_tokens} ]] && [[ "${tokens[i]}" == "${NL_MRK}" ]]; do
      while [[ ${i} -lt ${num_tokens} ]] && [[ "${tokens[i]}" == "${NL_MRK}" ]]; do
        chunk+=$'\n'
        i=$((i + 1))
      done
      if [[ ${i} -lt ${num_tokens} ]]; then
        chunk+="${tokens[i]}"
        word_count=$((word_count + 1))
        i=$((i + 1))
      fi
    done

    # Trailing space if the next token is a word (same-line continuation).
    if [[ ${i} -lt ${num_tokens} ]] && [[ "${tokens[i]}" != "${NL_MRK}" ]]; then
      chunk+=" "
    fi

    log::debug "Pasting chunk #${chunk_num} (${word_count} words): '${chunk}'"

    printf '%s' "${chunk}" | copy_clip
    simulate_paste
    sleep "${SLEEP_DELAY}"
  done

  # Restore original clipboard contents.
  copy_clip <<<"${original_clip}"
  log::info "Done. Original clipboard restored."
}

# Print contents of system clipboard to STDOUT.
function paste_clip() {
  if command -v pbpaste &>/dev/null; then
    pbpaste
  elif command -v xclip &>/dev/null; then
    xclip -selection clipboard -out
  else
    die "At least one of pbpaste OR xclip MUST be installed."
  fi
}

# Copy STDIN to system clipboard.
function copy_clip() {
  if command -v pbcopy &>/dev/null; then
    pbcopy
  elif command -v xclip &>/dev/null; then
    xclip -selection clipboard
  else
    die "At least one of pbcopy OR xclip MUST be installed."
  fi
}

# Simulate a paste keystroke in the active application.
function simulate_paste() {
  if [[ "$OSTYPE" == darwin* ]]; then
    osascript -e 'tell application "System Events" to keystroke "v" using command down'
  else
    xdotool key ctrl+v
  fi
}

function parse_cli_args() {
  log::debug "Command-Line Arguments: ($*)"

  eval set -- "$(getopt -o "h,n:,s:,v" -l "help,num-words:,sleep:,verbose" -- "$@")"

  VERBOSE=0
  NUM_WORDS=5
  SLEEP_DELAY=0.1
  while [[ -n "$1" ]]; do
    case $1 in
    -h | --help)
      echo "${DOC}"
      exit 0
      ;;
    -n | --num-words)
      shift
      NUM_WORDS="$1"
      ;;
    -s | --sleep)
      shift
      SLEEP_DELAY="$1"
      ;;
    -v | --verbose)
      VERBOSE=$((VERBOSE + 1))
      ;;
    --)
      shift
      break
      ;;
    esac
    shift
  done

  if [[ "${VERBOSE}" -gt 1 ]]; then
    PS4='$LINENO: '
    set -x
  fi

  if [[ $# -ne 0 ]]; then
    die "$(usage)" 2
  fi

  readonly DOC
  readonly VERBOSE
  readonly NUM_WORDS
  readonly SLEEP_DELAY
}

if [[ "${SCRIPTNAME}" == "$(basename "${BASH_SOURCE[0]}")" ]]; then
  run "$@"
fi
