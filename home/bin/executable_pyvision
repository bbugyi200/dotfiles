#!/usr/bin/env python3
"""Find unused public Python function and class definitions."""

import argparse
import ast
import re
import sys
from pathlib import Path


def _find_python_files(directory: Path, exclude_test_dirs: bool = True) -> list[Path]:
    """Find all .py files in directory, optionally excluding test directories."""
    exclude_patterns = (
        {"test", "tests", ".venv", "venv"} if exclude_test_dirs else set()
    )

    python_files = []
    for py_file in directory.rglob("*.py"):
        # Check if any parent directory is in exclude_patterns
        if any(part in exclude_patterns for part in py_file.parts):
            continue
        python_files.append(py_file)

    return python_files


def _extract_public_functions(file_path: Path) -> list[str]:
    """Extract all public top-level function and class names from a Python file."""
    try:
        with open(file_path, encoding="utf-8") as f:
            tree = ast.parse(f.read(), filename=str(file_path))

        symbols = []
        # Only iterate over module-level nodes, not nested functions/methods
        for node in tree.body:
            if isinstance(node, (ast.FunctionDef, ast.ClassDef)):
                # Only public symbols (not prefixed with _) and not named "main"
                if not node.name.startswith("_") and node.name != "main":
                    symbols.append(node.name)

        return symbols
    except (SyntaxError, UnicodeDecodeError) as e:
        print(f"Warning: Could not parse {file_path}: {e}", file=sys.stderr)
        return []


def _extract_private_functions(file_path: Path) -> list[str]:
    """Extract all private top-level function and class names from a Python file."""
    try:
        with open(file_path, encoding="utf-8") as f:
            tree = ast.parse(f.read(), filename=str(file_path))

        symbols = []
        # Only iterate over module-level nodes, not nested functions/methods
        for node in tree.body:
            if isinstance(node, (ast.FunctionDef, ast.ClassDef)):
                # Only private symbols (prefixed with _)
                if node.name.startswith("_"):
                    symbols.append(node.name)

        return symbols
    except (SyntaxError, UnicodeDecodeError) as e:
        print(f"Warning: Could not parse {file_path}: {e}", file=sys.stderr)
        return []


def _search_function_usage(function_name: str, search_files: list[Path]) -> bool:
    r"""Search for usage of a function or class in the given files.

    Uses two patterns:
    1. ^\s\s\s\s<symbol>,     - Symbol in a list with 4-space indentation
    2. from\s.*\simport.*\s<symbol> - Import statement
    """
    # Using word boundaries to ensure we match the exact symbol name
    patterns = [
        rf"^\s\s\s\s{re.escape(function_name)},",
        rf"from\s.*\simport.*\s{re.escape(function_name)}\b",
    ]

    for pattern in patterns:
        for file_path in search_files:
            try:
                with open(file_path, encoding="utf-8") as f:
                    content = f.read()
                    if re.search(pattern, content, re.MULTILINE):
                        return True
            except (UnicodeDecodeError, OSError):
                continue

    return False


def _is_private_function_used_in_file(function_name: str, file_path: Path) -> bool:
    """Check if a private function is used within its own file.

    Looks for the function being called or referenced, excluding the definition line.
    """
    try:
        with open(file_path, encoding="utf-8") as f:
            content = f.read()

        # Parse the file to get the definition line number
        tree = ast.parse(content, filename=str(file_path))
        def_line = None
        for node in tree.body:
            if isinstance(node, (ast.FunctionDef, ast.ClassDef)):
                if node.name == function_name:
                    def_line = node.lineno
                    break

        # Search for usage of the function (not in the definition line)
        lines = content.split("\n")
        for i, line in enumerate(lines, start=1):
            # Skip the definition line
            if i == def_line:
                continue

            # Look for function name being used (called, passed, etc.)
            # Use word boundary to avoid matching substrings
            if re.search(rf"\b{re.escape(function_name)}\b", line):
                return True

        return False
    except (UnicodeDecodeError, OSError, SyntaxError):
        return True  # Assume used if we can't parse


def main():
    parser = argparse.ArgumentParser(
        description="Find unused public Python function and class definitions"
    )
    parser.add_argument(
        "directory", type=Path, help="Directory to search for Python files"
    )
    args = parser.parse_args()

    if not args.directory.is_dir():
        print(f"Error: {args.directory} is not a directory", file=sys.stderr)
        return 1

    # Find all Python files excluding test directories
    python_files = _find_python_files(args.directory)

    if not python_files:
        print("No Python files found", file=sys.stderr)
        return 0

    # Collect all public functions and classes from all files
    all_symbols = {}  # {symbol_name: [file_path, ...]}
    for py_file in python_files:
        symbols = _extract_public_functions(py_file)
        for symbol in symbols:
            if symbol not in all_symbols:
                all_symbols[symbol] = []
            all_symbols[symbol].append(py_file)

    if not all_symbols:
        print("No public functions or classes found!", file=sys.stderr)
        return 0

    # Collect all private functions and classes from all files
    all_private_symbols = {}  # {symbol_name: [file_path, ...]}
    for py_file in python_files:
        private_symbols = _extract_private_functions(py_file)
        for symbol in private_symbols:
            if symbol not in all_private_symbols:
                all_private_symbols[symbol] = []
            all_private_symbols[symbol].append(py_file)

    # Check that private symbols do NOT match import patterns
    imported_private_symbols = []
    for symbol_name, def_files in all_private_symbols.items():
        if _search_function_usage(symbol_name, python_files):
            imported_private_symbols.append((symbol_name, def_files))

    if imported_private_symbols:
        print(
            "Error: Private functions/classes should not be imported:", file=sys.stderr
        )
        for symbol_name, def_files in sorted(imported_private_symbols):
            for file_path in def_files:
                print(f"  {symbol_name} in {file_path}", file=sys.stderr)
        return 1

    # Check that private symbols ARE used in their own file
    unused_private_symbols = []
    for symbol_name, def_files in all_private_symbols.items():
        for file_path in def_files:
            if not _is_private_function_used_in_file(symbol_name, file_path):
                unused_private_symbols.append((symbol_name, file_path))

    if unused_private_symbols:
        print(
            "Error: Private functions/classes must be used in the file where they are defined:",
            file=sys.stderr,
        )
        for symbol_name, file_path in sorted(unused_private_symbols):
            print(f"  {symbol_name} in {file_path}", file=sys.stderr)
        return 1

    # Search for usage of each symbol
    unused_symbols = []
    for symbol_name, def_files in all_symbols.items():
        if not _search_function_usage(symbol_name, python_files):
            unused_symbols.append((symbol_name, def_files))

    # Report results
    if unused_symbols:
        print("Unused public functions and classes:")
        for symbol_name, def_files in sorted(unused_symbols):
            for file_path in def_files:
                print(f"  {symbol_name} in {file_path}")
        return 1

    print("All public/private classes/functions are used properly!")
    return 0


if __name__ == "__main__":
    sys.exit(main())
