#!/usr/bin/env python3
"""Helper script for the #commit xprompt workflow.

Creates a new CL from uncommitted workspace changes.
"""

import argparse
import json
import os
import subprocess
import sys
import tempfile
from pathlib import Path

# Add gai source directory to path for imports
_GAI_SRC = Path.home() / "lib" / "gai" / "src"
if str(_GAI_SRC) not in sys.path:
    sys.path.insert(0, str(_GAI_SRC))


def _get_conflicting_changespec(project: str, cl_name: str) -> tuple[str, str] | None:
    """Check if cl_name conflicts with an existing non-revertable ChangeSpec.

    A conflict exists if any ChangeSpec has the same base name (after stripping
    the __<N> suffix) and has a status NOT in {"WIP", "Reverted"}. This prevents
    creating CLs that would conflict with existing active ChangeSpecs.

    Args:
        project: Project name.
        cl_name: CL name to check (with or without project prefix).

    Returns:
        Tuple of (conflicting_name, status) if conflict exists, None otherwise.
    """
    from ace.changespec import parse_project_file
    from gai_utils import strip_reverted_suffix
    from workflow_utils import get_project_file_path

    project_file = get_project_file_path(project)
    if not os.path.isfile(project_file):
        return None

    # Normalize: ensure project prefix
    full_name = cl_name
    if not cl_name.startswith(f"{project}_"):
        full_name = f"{project}_{cl_name}"

    # Get base name (strip any existing suffix)
    base_name = strip_reverted_suffix(full_name)

    changespecs = parse_project_file(project_file)
    for cs in changespecs:
        cs_base = strip_reverted_suffix(cs.name)
        if cs_base == base_name and cs.status not in {"WIP", "Reverted"}:
            return (cs.name, cs.status)

    return None


def _get_project_from_workspace() -> str | None:
    """Get the project name from the current workspace."""
    result = subprocess.run(
        ["workspace_name"], capture_output=True, text=True, check=False
    )
    if result.returncode != 0:
        return None
    return result.stdout.strip() or None


def _get_parent_branch() -> str | None:
    """Get the current branch name if on a named branch."""
    result = subprocess.run(
        ["branch_name"], capture_output=True, text=True, check=False
    )
    if result.returncode != 0:
        return None
    branch = result.stdout.strip()
    return branch if branch else None


def _run_command(cmd: str, capture_output: bool = True) -> subprocess.CompletedProcess:
    """Run a shell command."""
    return subprocess.run(
        cmd,
        shell=True,
        capture_output=capture_output,
        text=True,
    )


def _create_cl(
    name: str,
    bug_id: int,
    data_file: str,
) -> tuple[bool, str, str, str, str]:
    """Create a new CL from uncommitted changes.

    Args:
        name: The CL name (without project prefix).
        bug_id: Bug ID to link (0 for no bug).
        data_file: Path to JSON file containing prompt and response from agent.

    Returns:
        Tuple of (success, cl_url, full_cl_name, error_message, diff_path)
    """
    from chat_history import save_chat_history
    from commit_utils.workspace import save_diff
    from commit_workflow.branch_info import get_cl_number
    from commit_workflow.changespec_operations import add_changespec_to_project_file
    from commit_workflow.cl_formatting import format_cl_description
    from gai_utils import generate_timestamp
    from shared_utils import run_shell_command
    from summarize_utils import get_file_summary
    from workflow_utils import get_initial_hooks_for_changespec, get_project_file_path

    # Load prompt and response from data file
    with open(data_file, "r", encoding="utf-8") as f:
        data = json.load(f)
    prompt = data["prompt"]
    response = data["response"]

    # Get project name
    project = _get_project_from_workspace()
    if not project:
        return False, "", "", "Could not determine project from workspace", ""

    # Build full CL name with project prefix
    full_cl_name = name
    if not name.startswith(f"{project}_"):
        full_cl_name = f"{project}_{name}"

    # Check for conflicts
    conflict = _get_conflicting_changespec(project, full_cl_name)
    if conflict:
        conflict_name, conflict_status = conflict
        return (
            False,
            "",
            "",
            f"CL name conflicts with '{conflict_name}' (status: {conflict_status})",
            "",
        )

    # Get parent branch (if on a named branch)
    parent_branch = _get_parent_branch()

    # Save the current diff
    timestamp = generate_timestamp()
    diff_path = save_diff(full_cl_name, target_dir=None, timestamp=timestamp)

    # Save chat history to proper location (~/.gai/chats/)
    chat_path = save_chat_history(
        prompt=prompt,
        response=response,
        workflow="commit",
        timestamp=timestamp,
    )

    # Write response to temp file for get_file_summary (which expects a file path)
    fd_response, response_tmp = tempfile.mkstemp(suffix=".md", prefix="gai_commit_response_")
    try:
        with os.fdopen(fd_response, "w", encoding="utf-8") as f:
            f.write(response)
    except Exception:
        os.close(fd_response)
        raise

    # Generate description from response
    description = get_file_summary(
        response_tmp,
        usage="a concise description of what changes were made to the codebase",
        fallback="Changes made by agent",
    )

    # Write description to temp file for hg commit
    fd, desc_file = tempfile.mkstemp(suffix=".txt", prefix="gai_commit_desc_")
    try:
        with os.fdopen(fd, "w", encoding="utf-8") as f:
            f.write(description)

        # Format with [project] prefix for Mercurial commit message
        bug_str = str(bug_id) if bug_id > 0 else None
        format_cl_description(desc_file, project, bug=bug_str)

        # Run hg addremove to stage new/deleted files
        run_shell_command("hg addremove", capture_output=True)

        # If we have a parent branch, checkout to it first
        # This handles the case where another agent may have amended the parent CL
        if parent_branch:
            result = subprocess.run(
                ["bb_hg_update", parent_branch],
                capture_output=True,
                text=True,
                check=False,
            )
            if result.returncode != 0:
                # Continue anyway, not a fatal error
                pass

        # Create the Mercurial commit
        commit_cmd = f'hg commit --name "{full_cl_name}" --logfile "{desc_file}"'
        commit_result = run_shell_command(commit_cmd, capture_output=True)
        if commit_result.returncode != 0:
            return False, "", "", f"hg commit failed: {commit_result.stderr}", ""

        # Run hg fix (non-fatal if it fails)
        run_shell_command("hg fix", capture_output=True)

        # Run hg upload tree (non-fatal if it fails)
        run_shell_command("hg upload tree", capture_output=True)

        # Get CL number
        cl_number = get_cl_number()
        if not cl_number:
            return False, "", "", "Failed to get CL number after upload", ""
        cl_url = f"http://cl/{cl_number}"

        # Get initial hooks
        initial_hooks = get_initial_hooks_for_changespec(verbose=False)

        # Format bug as URL for ChangeSpec
        bug_url = f"http://b/{bug_id}" if bug_id > 0 else None

        # Create the ChangeSpec
        project_file = get_project_file_path(project)
        suffixed_name = add_changespec_to_project_file(
            project=project,
            cl_name=full_cl_name,
            description=description,
            parent=parent_branch,
            cl_url=cl_url,
            initial_hooks=initial_hooks,
            initial_commits=[(1, "[run] Initial Commit", chat_path, diff_path)],
            bug=bug_url,
        )

        if not suffixed_name:
            return False, "", "", "Failed to create ChangeSpec", ""

        # Rename the CL if needed to match the suffixed ChangeSpec name
        if suffixed_name != full_cl_name:
            run_shell_command(f'bb_hg_rename "{suffixed_name}"', capture_output=True)

        return True, cl_url, suffixed_name, "", diff_path or ""

    finally:
        # Clean up temp files
        for tmp_file in [desc_file, response_tmp]:
            try:
                os.unlink(tmp_file)
            except OSError:
                pass


def main() -> None:
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Helper for the #commit xprompt workflow"
    )
    parser.add_argument(
        "--create", action="store_true", help="Create a new CL from uncommitted changes"
    )
    parser.add_argument("--name", required=True, help="CL name (without project prefix)")
    parser.add_argument(
        "--bug-id", type=int, default=0, help="Bug ID to link (0 for no bug)"
    )
    parser.add_argument(
        "--data-file", required=True, help="Path to JSON file with prompt and response"
    )

    args = parser.parse_args()

    if args.create:
        success, cl_url, full_cl_name, error, diff_path = _create_cl(
            args.name, args.bug_id, args.data_file
        )
        print(f"success={'true' if success else 'false'}")
        print(f"cl_url={cl_url}")
        print(f"full_cl_name={full_cl_name}")
        print(f"diff_path={diff_path}")
        print(f"error={error}")
    else:
        parser.print_help()
        sys.exit(1)


if __name__ == "__main__":
    main()
