#!/usr/bin/env python3
"""Helper script for the #propose xprompt workflow.

Creates a proposal entry on an existing CL from uncommitted workspace changes.
"""

import argparse
import json
import os
import subprocess
import sys
import tempfile
from pathlib import Path

# Add gai source directory to path for imports
_GAI_SRC = Path.home() / "lib" / "gai" / "src"
if str(_GAI_SRC) not in sys.path:
    sys.path.insert(0, str(_GAI_SRC))


def _get_project_from_workspace() -> str | None:
    """Get the project name from the current workspace."""
    result = subprocess.run(
        ["workspace_name"], capture_output=True, text=True, check=False
    )
    if result.returncode != 0:
        return None
    return result.stdout.strip() or None


def _get_cl_name_from_branch() -> str | None:
    """Get the CL name from the current branch."""
    result = subprocess.run(
        ["branch_name"], capture_output=True, text=True, check=False
    )
    if result.returncode != 0:
        return None
    branch = result.stdout.strip()
    return branch if branch else None


def _create_proposal(
    who: str,
    note: str,
    data_file: str,
    start_timestamp: str = "",
) -> tuple[bool, str, str, str, str]:
    """Create a proposal entry on the current CL.

    Args:
        who: Identifier for who is creating the proposal (e.g., "man", "mentor:name").
        note: The note for the proposal (empty string to auto-generate).
        data_file: Path to JSON file containing prompt and response from agent.
        start_timestamp: Optional start timestamp from the parent workflow for chat
            duration calculation. If empty, uses the fresh timestamp.

    Returns:
        Tuple of (success, proposal_id, cl_name, error_message, diff_path)
    """
    from chat_history import save_chat_history
    from commit_utils.entries import add_proposed_commit_entry
    from commit_utils.workspace import clean_workspace, save_diff
    from gai_utils import generate_timestamp
    from summarize_utils import get_file_summary
    from workflow_utils import get_project_file_path

    # Load prompt and response from data file
    with open(data_file, "r", encoding="utf-8") as f:
        data = json.load(f)
    prompt = data["prompt"]
    response = data["response"]

    # Get CL name from branch
    cl_name = _get_cl_name_from_branch()
    if not cl_name:
        return False, "", "", "Could not determine CL name from branch", ""

    # Get project name
    project = _get_project_from_workspace()
    if not project:
        return False, "", "", "Could not determine project from workspace", ""

    # Get project file path
    project_file = get_project_file_path(project)
    if not os.path.exists(project_file):
        return False, "", "", f"Project file not found: {project_file}", ""

    # Generate timestamp for consistent filenames
    timestamp = generate_timestamp()

    # Save the current diff
    diff_path = save_diff(cl_name, target_dir=None, timestamp=timestamp)
    if not diff_path:
        return False, "", "", "No changes to save (diff is empty)", ""

    # Build note with [who] prefix
    if note:
        note = f"[{who}] {note}"
    else:
        # Auto-generate summary from response
        fd, response_tmp = tempfile.mkstemp(suffix=".md", prefix="gai_propose_response_")
        try:
            with os.fdopen(fd, "w", encoding="utf-8") as f:
                f.write(response)
            summary = get_file_summary(
                response_tmp,
                usage="a concise description of what changes were proposed",
                fallback="Proposed changes",
            )
        finally:
            try:
                os.unlink(response_tmp)
            except OSError:
                pass
        note = f"[{who}] {summary}"

    # Save chat history with actual prompt
    # Use start_timestamp for the chat file so that the CHAT duration
    # (end_timestamp - chat_path_timestamp) reflects the full agent runtime.
    chat_timestamp = start_timestamp if start_timestamp else timestamp
    chat_path = save_chat_history(
        prompt=prompt,
        response=response,
        workflow="propose",
        timestamp=chat_timestamp,
    )

    # Create the proposal entry
    success, proposal_id = add_proposed_commit_entry(
        project_file=project_file,
        cl_name=cl_name,
        note=note,
        diff_path=diff_path,
        chat_path=chat_path,
        end_timestamp=timestamp,
    )

    if not success:
        return False, "", "", f"Failed to add proposal entry to ChangeSpec for {cl_name}", ""

    # Clean the workspace (revert changes)
    clean_workspace(os.getcwd())

    return True, proposal_id or "", cl_name, "", diff_path or ""


def main() -> None:
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Helper for the #propose xprompt workflow"
    )
    parser.add_argument(
        "--create", action="store_true", help="Create a proposal on the current CL"
    )
    parser.add_argument(
        "--who", default="man", help="Identifier for who is creating the proposal"
    )
    parser.add_argument(
        "--note", default="", help="Note for the proposal (auto-generated if empty)"
    )
    parser.add_argument(
        "--data-file", required=True, help="Path to JSON file with prompt and response"
    )
    parser.add_argument(
        "--start-timestamp",
        default="",
        help="Start timestamp from the parent workflow (for chat duration calculation)",
    )

    args = parser.parse_args()

    if args.create:
        success, proposal_id, cl_name, error, diff_path = _create_proposal(
            args.who, args.note, args.data_file, args.start_timestamp
        )
        print(f"success={'true' if success else 'false'}")
        print(f"proposal_id={proposal_id}")
        print(f"cl_name={cl_name}")
        print(f"diff_path={diff_path}")
        print(f"error={error}")
    else:
        parser.print_help()
        sys.exit(1)


if __name__ == "__main__":
    main()
