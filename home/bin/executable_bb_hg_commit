#!/bin/bash

source ~/lib/bugyi.sh

export USAGE_GRAMMAR=(
  "[-v] [-b BUG] [-p PROJECT] FILE_PATH NAME"
  "-h"
)

read -r -d '' DOC <<EOM
$(usage)

Create a Mercurial commit with formatted CL description and metadata tags.

Positional Arguments
--------------------
FILE_PATH
    Path to the file containing the CL description.

NAME
    CL name to use for the commit (e.g., "foobar_baz_feature").

Optional Arguments
------------------
-b BUG | --bug BUG
    Bug number to include in the metadata tags (e.g., "12345").
    Defaults to the output of the 'branch_bug' command.

-h | --help
    View this help message.

-p PROJECT | --project PROJECT
    Project name to prepend to the CL description (e.g., "foobar").
    Defaults to the output of the 'workspace_name' command.

-v | --verbose
    Enable verbose output. This option can be specified multiple times (e.g. -v, -vv, ...).

Examples
--------
$(basename "${BASH_SOURCE[0]}") /tmp/cl_description.txt my_feature_cl
$(basename "${BASH_SOURCE[0]}") -b 12345 -p myproject /tmp/cl_description.txt my_feature_cl
$(basename "${BASH_SOURCE[0]}") -v /path/to/desc.txt foobar_baz_feature

EOM

function run() {
  parse_cli_args "$@"

  if [[ ! -f "${FILE_PATH}" ]]; then
    die "File does not exist: %s" "${FILE_PATH}"
  fi

  log::info "Formatting CL description with project tag and metadata."
  format_cl_description "${FILE_PATH}" "${PROJECT}" "${BUG}"

  # Running `hg addremove` is necessary when adding new / deleting old files.
  hg addremove

  log::info "Creating Mercurial commit with name: %s" "${NAME}"
  if ! hg commit --name "${NAME}" --logfile "${FILE_PATH}"; then
    die "Failed to create Mercurial commit."
  else
    hg fix
    hg upload tree
    rm -f bb/branch_name.txt
  fi

  log::info "Retrieving CL number."
  if ! branch_number; then
    die "Failed to retrieve CL number."
  fi
}

function parse_cli_args() {
  log::debug "Command-Line Arguments: ($*)"

  eval set -- "$(getopt -o "b:,h,p:,v" -l "bug:,help,project:,verbose" -- "$@")"

  VERBOSE=0
  BUG=""
  PROJECT=""
  while [[ -n "$1" ]]; do
    case $1 in
    -b | --bug)
      shift
      BUG="$1"
      ;;
    -h | --help)
      echo "${DOC}"
      exit 0
      ;;
    -p | --project)
      shift
      PROJECT="$1"
      ;;
    -v | --verbose)
      VERBOSE=$((VERBOSE + 1))
      ;;
    --)
      shift
      break
      ;;
    esac
    shift
  done

  if [[ "${VERBOSE}" -gt 1 ]]; then
    PS4='$LINENO: '
    set -x
  fi

  if [[ $# -ne 2 ]]; then
    die "$(usage)" 2
  fi

  FILE_PATH="$1"
  NAME="$2"

  # Set defaults from commands if not provided
  if [[ -z "${BUG}" ]]; then
    if ! BUG="$(branch_bug)"; then
      die "Failed to get bug number from 'branch_bug' command. Use -b to specify manually."
    fi
  fi

  if [[ -z "${PROJECT}" ]]; then
    if ! PROJECT="$(workspace_name)"; then
      die "Failed to get project name from 'workspace_name' command. Use -p to specify manually."
    fi
  fi

  readonly DOC
  readonly VERBOSE
  readonly BUG
  readonly PROJECT
  readonly FILE_PATH
  readonly NAME
}

function format_cl_description() {
  local file_path="$1"
  local project="$2"
  local bug="$3"

  local temp_file="${file_path}.tmp"

  # Read the original content
  local content
  content=$(cat "${file_path}")

  # Write the formatted content to a temporary file
  {
    echo "[${project}] ${content}"
    echo ""
    echo "AUTOSUBMIT_BEHAVIOR=SYNC_SUBMIT"
    echo "BUG=${bug}"
    echo "MARKDOWN=true"
    echo "R=startblock"
    echo "STARTBLOCK_AUTOSUBMIT=yes"
    echo "WANT_LGTM=all"
  } >"${temp_file}"

  # Replace the original file with the formatted version
  mv "${temp_file}" "${file_path}"

  log::debug "Formatted CL description written to: %s" "${file_path}"
}

if [[ "${SCRIPTNAME}" == "$(basename "${BASH_SOURCE[0]}")" ]]; then
  run "$@"
fi
