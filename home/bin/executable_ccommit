#!/bin/bash

source ~/lib/bugyi.sh

CCOMMIT_LOG="${HOME}/.ccommit.jsonl"
CCOMMIT_START_EPOCH=$(date +%s)

# Write a structured JSON log line to ~/.ccommit.jsonl.
# Usage: jlog <event> [key=value ...]
# Silently no-ops if jq is not installed.
function jlog() {
  command -v jq &>/dev/null || return 0
  local event="$1"
  shift

  local jq_args=()
  local jq_pairs=""
  local i=0

  while [[ $# -gt 0 ]]; do
    local key="${1%%=*}"
    local val="${1#*=}"
    jq_args+=("--arg" "k${i}" "$key" "--arg" "v${i}" "$val")
    jq_pairs+=", (\$k${i}): \$v${i}"
    i=$((i + 1))
    shift
  done

  jq -c -n --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" --arg event "$event" \
    "${jq_args[@]}" \
    "{timestamp: \$ts, event: \$event${jq_pairs}}" >> "${CCOMMIT_LOG}" 2>/dev/null
}

function on_exit() {
  local exit_code=$?
  local elapsed=$(( $(date +%s) - CCOMMIT_START_EPOCH ))
  jlog "script_exit" "exit_code=${exit_code}" "duration_s=${elapsed}"
}
trap on_exit EXIT

export USAGE_GRAMMAR=(
  "[-v] [--bead <id>] <tag> <message> <file>..."
  "-h"
)

read -r -d '' DOC <<EOM
$(usage)

Create a conventional commit with a validated tag.

Positional Arguments
--------------------
<tag>
    A conventional commit tag. Listed in order of preference:
      1. feat  - New feature, feature improvement, or feature removal
      2. fix   - User-facing bug fix (not linting errors unless they caught a real bug)
      3. ref   - Refactor/restructure production code without changing external behavior
      4. chore - Other changes (build scripts, CI/CD, deps) not modifying production code

<message>
    The commit message. May contain newlines for multi-line messages.
    The first line becomes the commit subject, subsequent lines become the body.

<file>...
    One or more file paths to stage before committing.
    These files will be staged using 'git add'.

Optional Arguments
------------------
-h | --help
    View this help message.

-v | --verbose
    Enable verbose output. This option can be specified multiple times (e.g. -v, -vv, ...).

--bead <id>
    A bead issue ID to associate with this commit. When provided, the bead ID
    is appended to the commit headline in parentheses, e.g. "feat: Message (beads-xxx)".

Examples
--------
ccommit feat "Add user authentication" src/auth.py src/login.py
ccommit fix "Resolve null pointer in login

This fixes the crash that occurred when the user was not logged in." src/login.py
ccommit -v chore "Update dependencies" package.json
EOM

VALID_TAGS=("feat" "fix" "ref" "chore")

# Main entry point. Parses arguments, validates environment, and creates the commit.
function run() {
  local branch
  branch=$(git symbolic-ref --short HEAD 2>/dev/null || echo "detached")
  jlog "script_start" \
    "args=$*" \
    "working_dir=$(pwd)" \
    "branch=${branch}" \
    "pid=$$"
  parse_cli_args "$@"
  stage_files
  validate_staged_changes
  merge_with_master
  do_commit
  do_push
  do_beads_sync
  send_notification
}

# Parse and validate command-line arguments. Sets TAG and MESSAGE globals.
function parse_cli_args() {
  log::debug "Command-Line Arguments: ($*)"

  eval set -- "$(getopt -o "b:,h,v" -l "bead:,help,verbose" -- "$@")"

  BEAD_ID=""
  VERBOSE=0
  while [[ -n "$1" ]]; do
    case $1 in
    -b | --bead)
      shift
      BEAD_ID="$1"
      ;;
    -h | --help)
      echo "${DOC}"
      exit 0
      ;;
    -v | --verbose)
      VERBOSE=$((VERBOSE + 1))
      ;;
    --)
      shift
      break
      ;;
    esac
    shift
  done

  if [[ "${VERBOSE}" -gt 1 ]]; then
    PS4='$LINENO: '
    set -x
  fi

  # Validate positional arguments
  if [[ $# -lt 3 ]]; then
    die -x2 "$(usage)"
  fi

  TAG="$1"
  shift
  MESSAGE="$1"
  shift
  FILES=("$@")

  # Validate tag
  local valid_tag=false
  for t in "${VALID_TAGS[@]}"; do
    if [[ "${TAG}" == "${t}" ]]; then
      valid_tag=true
      break
    fi
  done

  if [[ "${valid_tag}" == "false" ]]; then
    die -x2 "Invalid tag '${TAG}'. Must be one of: ${VALID_TAGS[*]}"
  fi

  readonly BEAD_ID
  readonly DOC
  readonly VERBOSE
  readonly TAG
  readonly MESSAGE
  readonly FILES

  jlog "cli_parsed" \
    "tag=${TAG}" \
    "message=${MESSAGE}" \
    "files=${FILES[*]}" \
    "bead_id=${BEAD_ID}" \
    "verbose=${VERBOSE}"
}

# Stage the specified files using git add.
function stage_files() {
  log::debug "Staging files: ${FILES[*]}"
  local rc=0
  git add -- "${FILES[@]}" || rc=$?
  jlog "stage_files" "files=${FILES[*]}" "exit_code=${rc}"
  if [[ ${rc} -ne 0 ]]; then
    die "git add failed (exit code ${rc})"
  fi
}

# Verify there are staged changes to commit. Dies with an error if nothing is staged.
function validate_staged_changes() {
  if git diff --cached --quiet; then
    jlog "validate_staged" "result=no_changes"
    die "No staged changes to commit"
  fi
  jlog "validate_staged" "result=ok"
  log::debug "Validated: staged changes exist"
}

# Merge the current branch with master/main to keep it up-to-date.
# Skips if already on master/main. Fails with actionable message on conflict.
function merge_with_master() {
  local current_branch
  current_branch=$(git symbolic-ref --short HEAD 2>/dev/null || {
    jlog "merge" "result=skipped" "reason=detached_head"
    return 0
  })

  # Determine default branch name
  local default_branch=""
  for candidate in master main; do
    if git show-ref --verify --quiet "refs/remotes/origin/${candidate}" 2>/dev/null; then
      default_branch="${candidate}"
      break
    fi
  done

  if [[ -z "${default_branch}" ]]; then
    jlog "merge" "result=skipped" "reason=no_default_branch" "current_branch=${current_branch}"
    log::debug "No master/main branch found on origin, skipping merge"
    return 0
  fi

  jlog "merge_start" "current_branch=${current_branch}" "default_branch=${default_branch}"

  if [[ "${current_branch}" == "${default_branch}" ]]; then
    log::debug "Pulling latest origin/${default_branch}"
    git fetch origin "${default_branch}" --quiet
    # Stash staged changes, pull, then restore
    git stash --quiet --keep-index
    local stashed_default=$?
    if ! git merge "origin/${default_branch}" --no-edit --quiet 2>&1; then
      git merge --abort
      if [[ ${stashed_default} -eq 0 ]]; then
        git stash pop --quiet 2>/dev/null || true
      fi
      jlog "merge" "result=conflict" "detail=sync_${default_branch}_with_origin"
      die "Merge conflict when syncing ${default_branch} with origin/${default_branch}. Please resolve the conflict manually, then re-run ccommit."
    fi
    if [[ ${stashed_default} -eq 0 ]]; then
      git stash pop --quiet || {
        jlog "merge" "result=stash_pop_failed" "detail=on_default_branch"
        die "Failed to restore staged changes after merge. Your changes are in git stash. Run 'git stash pop' to recover them, resolve any conflicts, then re-run ccommit."
      }
    fi
    jlog "merge" "result=ok" "detail=pulled_origin_${default_branch}"
    return 0
  fi

  log::debug "Merging origin/${default_branch} into ${current_branch}"
  git fetch origin "${default_branch}" --quiet

  # Stash staged changes before merge
  git stash --quiet --keep-index
  local stashed=$?

  if ! git merge "origin/${default_branch}" --no-edit --quiet 2>&1; then
    git merge --abort
    # Restore stashed changes
    if [[ ${stashed} -eq 0 ]]; then
      git stash pop --quiet 2>/dev/null || true
    fi
    jlog "merge" "result=conflict" "detail=merge_${default_branch}_into_${current_branch}"
    die "Merge conflict when syncing ${current_branch} with origin/${default_branch}. Please resolve the conflict manually (git merge origin/${default_branch}), then re-run ccommit."
  fi

  # Restore stashed changes
  if [[ ${stashed} -eq 0 ]]; then
    git stash pop --quiet || {
      jlog "merge" "result=stash_pop_failed" "detail=on_feature_branch"
      die "Failed to restore staged changes after merge. Your changes are in git stash. Run 'git stash pop' to recover them, resolve any conflicts, then re-run ccommit."
    }
  fi
  jlog "merge" "result=ok" "detail=merged_origin_${default_branch}_into_${current_branch}"
}

# Build the commit message and execute 'git commit'.
function do_commit() {
  local message="${TAG}: ${MESSAGE}"
  if [[ -n "${BEAD_ID}" ]]; then
    # Inject bead reference into the first line of the commit message
    local first_line="${message%%$'\n'*}"
    local rest="${message#"$first_line"}"
    message="${first_line} (${BEAD_ID})${rest}"
  fi
  log::debug "Commit message:\n%s" "${message}"
  local rc=0
  git commit -F - <<<"${message}" || rc=$?
  if [[ ${rc} -ne 0 ]]; then
    jlog "commit" "result=failed" "exit_code=${rc}" "message=${message}"
    die "git commit failed (exit code ${rc})"
  fi
  local commit_hash
  commit_hash=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
  jlog "commit" "result=ok" "commit_hash=${commit_hash}" "message=${message}"
}

# Push commits to remote.
function do_push() {
  log::debug "Pushing to remote"
  local rc=0
  git push || rc=$?
  if [[ ${rc} -ne 0 ]]; then
    jlog "push" "result=failed" "exit_code=${rc}"
    die "git push failed (exit code ${rc})"
  fi
  jlog "push" "result=ok"
}

# Sync beads issue tracker state after push.
function do_beads_sync() {
  if command -v bd >/dev/null 2>&1 && [ -d .beads ]; then
    log::debug "Syncing beads"
    local rc=0
    bd sync 2>/dev/null || rc=$?
    jlog "beads_sync" "result=$([ ${rc} -eq 0 ] && echo ok || echo failed)" "exit_code=${rc}"
  else
    jlog "beads_sync" "result=skipped"
  fi
}

# Send Mac notification with commit details.
function send_notification() {
  local message="${TAG}: ${MESSAGE}"
  if [[ -n "${BEAD_ID}" ]]; then
    local first_line="${message%%$'\n'*}"
    local rest="${message#"$first_line"}"
    message="${first_line} (${BEAD_ID})${rest}"
  fi
  local project_name
  project_name=$(basename "${CLAUDE_PROJECT_DIR:-$(git rev-parse --show-toplevel 2>/dev/null || pwd)}")
  local prefix="\[${project_name}]"
  if [[ -n "$TMUX_PANE" ]]; then
    local window
    window=$(tmux display-message -t "$TMUX_PANE" -p '#W' 2>/dev/null)
    if [[ -n "$window" ]]; then
      prefix="\[${project_name}#${window}]"
    fi
  fi
  if [[ "$(uname)" == "Darwin" ]]; then
    terminal-notifier -title "${prefix} New Commit Created" -message "${message}"
  elif command -v notify-send &>/dev/null; then
    notify-send "${prefix} New Commit Created" "${message}"
  fi
}

if [[ "${SCRIPTNAME}" == "$(basename "${BASH_SOURCE[0]}")" ]]; then
  run "$@"
fi
