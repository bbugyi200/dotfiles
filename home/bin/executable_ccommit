#!/bin/bash

source ~/lib/bugyi.sh

export USAGE_GRAMMAR=(
  "[-v] [--bead <id>] <tag> <message> <file>..."
  "-h"
)

read -r -d '' DOC <<EOM
$(usage)

Create a conventional commit with a validated tag.

Positional Arguments
--------------------
<tag>
    A conventional commit tag. Listed in order of preference:
      1. feat  - New feature, feature improvement, or feature removal
      2. fix   - User-facing bug fix (not linting errors unless they caught a real bug)
      3. ref   - Refactor/restructure production code without changing external behavior
      4. chore - Other changes (build scripts, CI/CD, deps) not modifying production code

<message>
    The commit message. May contain newlines for multi-line messages.
    The first line becomes the commit subject, subsequent lines become the body.

<file>...
    One or more file paths to stage before committing.
    These files will be staged using 'git add'.

Optional Arguments
------------------
-h | --help
    View this help message.

-v | --verbose
    Enable verbose output. This option can be specified multiple times (e.g. -v, -vv, ...).

--bead <id>
    A bead issue ID to associate with this commit. When provided, the bead ID
    is appended to the commit headline in parentheses, e.g. "feat: Message (beads-xxx)".

Examples
--------
ccommit feat "Add user authentication" src/auth.py src/login.py
ccommit fix "Resolve null pointer in login

This fixes the crash that occurred when the user was not logged in." src/login.py
ccommit -v chore "Update dependencies" package.json
EOM

VALID_TAGS=("feat" "fix" "ref" "chore")

# Main entry point. Parses arguments, validates environment, and creates the commit.
function run() {
  parse_cli_args "$@"
  stage_files
  validate_staged_changes
  merge_with_master
  do_commit
  do_push
  do_beads_sync
  send_notification
}

# Parse and validate command-line arguments. Sets TAG and MESSAGE globals.
function parse_cli_args() {
  log::debug "Command-Line Arguments: ($*)"

  eval set -- "$(getopt -o "b:,h,v" -l "bead:,help,verbose" -- "$@")"

  BEAD_ID=""
  VERBOSE=0
  while [[ -n "$1" ]]; do
    case $1 in
    -b | --bead)
      shift
      BEAD_ID="$1"
      ;;
    -h | --help)
      echo "${DOC}"
      exit 0
      ;;
    -v | --verbose)
      VERBOSE=$((VERBOSE + 1))
      ;;
    --)
      shift
      break
      ;;
    esac
    shift
  done

  if [[ "${VERBOSE}" -gt 1 ]]; then
    PS4='$LINENO: '
    set -x
  fi

  # Validate positional arguments
  if [[ $# -lt 3 ]]; then
    die -x2 "$(usage)"
  fi

  TAG="$1"
  shift
  MESSAGE="$1"
  shift
  FILES=("$@")

  # Validate tag
  local valid_tag=false
  for t in "${VALID_TAGS[@]}"; do
    if [[ "${TAG}" == "${t}" ]]; then
      valid_tag=true
      break
    fi
  done

  if [[ "${valid_tag}" == "false" ]]; then
    die -x2 "Invalid tag '${TAG}'. Must be one of: ${VALID_TAGS[*]}"
  fi

  readonly BEAD_ID
  readonly DOC
  readonly VERBOSE
  readonly TAG
  readonly MESSAGE
  readonly FILES
}

# Stage the specified files using git add.
function stage_files() {
  log::debug "Staging files: ${FILES[*]}"
  git add -- "${FILES[@]}"
}

# Verify there are staged changes to commit. Dies with an error if nothing is staged.
function validate_staged_changes() {
  if git diff --cached --quiet; then
    die "No staged changes to commit"
  fi
  log::debug "Validated: staged changes exist"
}

# Merge the current branch with master/main to keep it up-to-date.
# Skips if already on master/main. Fails with actionable message on conflict.
function merge_with_master() {
  local current_branch
  current_branch=$(git symbolic-ref --short HEAD 2>/dev/null || return 0)

  # Determine default branch name
  local default_branch=""
  for candidate in master main; do
    if git show-ref --verify --quiet "refs/remotes/origin/${candidate}" 2>/dev/null; then
      default_branch="${candidate}"
      break
    fi
  done

  if [[ -z "${default_branch}" ]]; then
    log::debug "No master/main branch found on origin, skipping merge"
    return 0
  fi

  if [[ "${current_branch}" == "${default_branch}" ]]; then
    log::debug "Pulling latest origin/${default_branch}"
    git fetch origin "${default_branch}" --quiet
    # Stash staged changes, pull, then restore
    git stash --quiet --keep-index
    local stashed_default=$?
    if ! git merge "origin/${default_branch}" --no-edit --quiet 2>&1; then
      git merge --abort
      if [[ ${stashed_default} -eq 0 ]]; then
        git stash pop --quiet 2>/dev/null || true
      fi
      die "Merge conflict when syncing ${default_branch} with origin/${default_branch}. Please resolve the conflict manually, then re-run ccommit."
    fi
    if [[ ${stashed_default} -eq 0 ]]; then
      git stash pop --quiet || die "Failed to restore staged changes after merge. Your changes are in git stash. Run 'git stash pop' to recover them, resolve any conflicts, then re-run ccommit."
    fi
    return 0
  fi

  log::debug "Merging origin/${default_branch} into ${current_branch}"
  git fetch origin "${default_branch}" --quiet

  # Stash staged changes before merge
  git stash --quiet --keep-index
  local stashed=$?

  if ! git merge "origin/${default_branch}" --no-edit --quiet 2>&1; then
    git merge --abort
    # Restore stashed changes
    if [[ ${stashed} -eq 0 ]]; then
      git stash pop --quiet 2>/dev/null || true
    fi
    die "Merge conflict when syncing ${current_branch} with origin/${default_branch}. Please resolve the conflict manually (git merge origin/${default_branch}), then re-run ccommit."
  fi

  # Restore stashed changes
  if [[ ${stashed} -eq 0 ]]; then
    git stash pop --quiet || die "Failed to restore staged changes after merge. Your changes are in git stash. Run 'git stash pop' to recover them, resolve any conflicts, then re-run ccommit."
  fi
}

# Build the commit message and execute 'git commit'.
function do_commit() {
  local message="${TAG}: ${MESSAGE}"
  if [[ -n "${BEAD_ID}" ]]; then
    # Inject bead reference into the first line of the commit message
    local first_line="${message%%$'\n'*}"
    local rest="${message#"$first_line"}"
    message="${first_line} (${BEAD_ID})${rest}"
  fi
  log::debug "Commit message:\n%s" "${message}"
  git commit -F - <<<"${message}"
}

# Push commits to remote.
function do_push() {
  log::debug "Pushing to remote"
  git push
}

# Sync beads issue tracker state after push.
function do_beads_sync() {
  if command -v bd >/dev/null 2>&1 && [ -d .beads ]; then
    log::debug "Syncing beads"
    bd sync 2>/dev/null || true
  fi
}

# Send Mac notification with commit details.
function send_notification() {
  local message="${TAG}: ${MESSAGE}"
  if [[ -n "${BEAD_ID}" ]]; then
    local first_line="${message%%$'\n'*}"
    local rest="${message#"$first_line"}"
    message="${first_line} (${BEAD_ID})${rest}"
  fi
  local project_name
  project_name=$(basename "${CLAUDE_PROJECT_DIR:-$(git rev-parse --show-toplevel 2>/dev/null || pwd)}")
  local prefix="\[${project_name}]"
  if [[ -n "$TMUX_PANE" ]]; then
    local window
    window=$(tmux display-message -t "$TMUX_PANE" -p '#W' 2>/dev/null)
    if [[ -n "$window" ]]; then
      prefix="\[${project_name}#${window}]"
    fi
  fi
  if [[ "$(uname)" == "Darwin" ]]; then
    terminal-notifier -title "${prefix} New Commit Created" -message "${message}"
  elif command -v notify-send &>/dev/null; then
    notify-send "${prefix} New Commit Created" "${message}"
  fi
}

if [[ "${SCRIPTNAME}" == "$(basename "${BASH_SOURCE[0]}")" ]]; then
  run "$@"
fi
