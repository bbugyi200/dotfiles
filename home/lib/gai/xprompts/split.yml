name: split
# Workflow-level configuration for automatic resource management
config:
  claim_workspace: true
  create_artifacts: true
  log_workflow: true

input:
  - name: cl_name
    type: word
    default: "" # Empty means use current branch

steps:
  # Step 1: Setup - navigate to CL and gather metadata
  - name: setup
    python: |
      import os
      import subprocess

      from ace.changespec import find_all_changespecs

      cl_name = "{{ cl_name }}"
      if not cl_name:
          cl_name = subprocess.run(
              ["branch_name"], capture_output=True, text=True, check=True
          ).stdout.strip()

      # Validate no children
      cs_list = find_all_changespecs()
      children = [
          cs for cs in cs_list if cs.parent == cl_name and cs.status != "Reverted"
      ]
      if children:
          print("error=Cannot split: CL has child CLs")
          exit(1)

      # Get default parent
      target = next((cs for cs in cs_list if cs.name == cl_name), None)
      default_parent = target.parent if target and target.parent else "p4head"

      # Navigate and save diff
      subprocess.run(["bb_hg_clean", f"{cl_name}-split-nav"], check=True)
      subprocess.run(["bb_hg_update", cl_name], check=True)
      os.makedirs("bb/gai", exist_ok=True)
      diff_path = f"bb/gai/{cl_name}.diff"
      with open(diff_path, "w") as f:
          result = subprocess.run(
              ["branch_diff"], capture_output=True, text=True, check=True
          )
          f.write(result.stdout)

      bug = subprocess.run(
          ["branch_bug"], capture_output=True, text=True, check=True
      ).stdout.strip()
      workspace = subprocess.run(
          ["workspace_name"], capture_output=True, text=True, check=True
      ).stdout.strip()

      print(f"cl_name={cl_name}")
      print(f"diff_path={diff_path}")
      print(f"bug={bug}")
      print(f"workspace_name={workspace}")
      print(f"default_parent={default_parent}")
    output:
      type: json_schema
      schema:
        properties:
          cl_name:
            type: word
          diff_path:
            type: path
          bug:
            type: line
          workspace_name:
            type: word
          default_parent:
            type: word

  # Step 2: Generate split spec (agent with HITL)
  - name: generate_spec
    agent: split_spec_generator
    prompt: |
      #split_spec_generator(
        workspace_name="{{ setup.workspace_name }}",
        diff_path="{{ setup.diff_path }}"
      )
    output:
      type: json_schema
      schema:
        type: array
        items:
          type: object
          required:
            - name
            - description
          properties:
            name:
              type: word
            description:
              type: text
            parent:
              type: word
    hitl: true

  # Step 3: Format spec and navigate to parent
  - name: prepare_execute
    python: |
      import json
      import subprocess
      from datetime import datetime
      from pathlib import Path
      from typing import Any

      import yaml

      spec: Any = {{ generate_spec | tojson }}
      # Handle _data wrapper if present (arrays get wrapped by workflow executor)
      if isinstance(spec, dict) and "_data" in spec:
          spec = spec["_data"]

      # Archive spec
      timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
      archive_dir = Path.home() / ".gai" / "splits"
      archive_dir.mkdir(parents=True, exist_ok=True)
      archive_path = archive_dir / f"{{ setup.cl_name }}-{timestamp}.yml"
      with open(archive_path, "w") as f:
          yaml.dump(spec, f)

      # Topological sort
      result: list[dict[str, Any]] = []
      seen: set[str] = set()

      def visit(name: str) -> None:
          if name in seen:
              return
          seen.add(name)
          entry = next((e for e in spec if e["name"] == name), None)
          if entry and entry.get("parent"):
              p = next((e for e in spec if e["name"] == entry["parent"]), None)
              if p:
                  visit(p["name"])
          if entry:
              result.append(entry)

      for e in spec:
          visit(e["name"])

      # Format markdown
      md_lines = []
      order_lines = []
      for i, e in enumerate(result):
          parent_suffix = f" (parent: {e['parent']})" if e.get("parent") else ""
          md_lines.append(f"- **{e['name']}**: {e['description']}{parent_suffix}")
          order_lines.append(f"{i+1}. {e['name']}{parent_suffix}")

      # Navigate to parent (suppress output to preserve JSON)
      subprocess.run(
          ["bb_hg_clean", "{{ setup.cl_name }}-split-parent"],
          capture_output=True,
          check=True,
      )
      subprocess.run(
          ["bb_hg_update", "{{ setup.default_parent }}"],
          capture_output=True,
          check=True,
      )

      # Output as JSON (parser handles this correctly for multiline values)
      print(
          json.dumps(
              {
                  "spec_markdown": "\n".join(md_lines),
                  "processing_order": "\n".join(order_lines),
                  "archive_path": str(archive_path),
              }
          )
      )
    output:
      type: json_schema
      schema:
        properties:
          archive_path:
            type: path
          spec_markdown:
            type: text
          processing_order:
            type: text

  # Step 4: Execute split (agent)
  - name: execute_split
    agent: split_executor
    prompt: |
      #split_executor(
        diff_path="{{ setup.diff_path }}",
        spec_markdown="{{ prepare_execute.spec_markdown }}",
        default_parent="{{ setup.default_parent }}",
        bug_flag="{{ '-b ' + setup.bug if setup.bug else '' }}",
        note="Split from {{ setup.cl_name }} ({{ prepare_execute.archive_path }})",
        processing_order="{{ prepare_execute.processing_order }}"
      )

  # Step 5: Prompt to revert original CL (HITL)
  - name: revert_prompt
    bash: |
      echo "message=Revert the original CL '{{ setup.cl_name }}'?"
    output:
      type: json_schema
      schema:
        properties:
          message:
            type: text
    hitl: true

  # Step 6: Execute revert if approved
  - name: execute_revert
    python: |
      # revert_prompt.approved is set by HITL handler
      approved = {{ revert_prompt.approved | tojson }}
      if approved:
          from ace.changespec import find_all_changespecs
          from ace.revert import revert_changespec
          from rich.console import Console

          cs = next((c for c in find_all_changespecs() if c.name == "{{ setup.cl_name }}"), None)
          if cs:
              success, _ = revert_changespec(cs, Console())
              print("reverted=" + ("true" if success else "false"))
          else:
              print("reverted=false")
      else:
          print("reverted=skipped")
    output:
      type: json_schema
      schema:
        properties:
          reverted:
            type: word
