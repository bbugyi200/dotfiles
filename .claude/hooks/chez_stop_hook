#!/bin/bash

# Directory containing this script (the .claude/hooks directory)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$(dirname "$SCRIPT_DIR")")"

# File patterns for conditional execution
PYTHON_PATTERN='^home/lib/.*\.py$'
LUA_PATTERN='^(home/dot_config/nvim|tests/nvim|home/lib)/.*\.lua$'
BASH_PATTERN='^(home/lib/bugyi\.sh|tests/bash/bugyi_test\.sh)$'

# Get list of uncommitted changed files
function get_changed_files() {
    git diff --name-only HEAD 2>/dev/null
}

# Check if any changed files match a pattern
function has_changes_matching() {
    local pattern="$1"
    get_changed_files | grep -qE "$pattern"
}

# Print the command we are about to run.
function print_cmd_to_user() {
    local cmd="$1"
    shift
    echo "[chez_stop_hook] Running \`$cmd\`..."
}

# Format seconds as XhYmZs
function format_duration() {
    local total_seconds=$1
    local hours=$((total_seconds / 3600))
    local minutes=$(((total_seconds % 3600) / 60))
    local seconds=$((total_seconds % 60))
    if [[ "${hours}" != "0" ]]; then
        echo "${hours}h${minutes}m${seconds}s"
    else
        echo "${minutes}m${seconds}s"
    fi
}

# Send Mac notification with result
function send_notification() {
    local passed=$1
    local elapsed_seconds=$2
    local errors="$3"
    local prefix="\[chez]"
    local window
    if window=$(tmux display-message -p '#W' 2>/dev/null); then
        prefix="\[chez#${window}]"
    fi

    local title
    local message

    if [ "$passed" = "true" ]; then
        title="${prefix} Stop Hook - PASSED"
        message="RUNTIME: $(format_duration "$elapsed_seconds")"
    else
        title="${prefix} Stop Hook - FAILED"
        message="$errors"
    fi

    terminal-notifier -title "$title" -message "$message"
}

# Run quality checks conditionally based on changed files
function run() {
    cd "$PROJECT_DIR" || return 1

    # Track start time for notification
    local start_time
    start_time=$(date +%s)

    # Log that this hook ran
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] chez_stop_hook ran" >>"$SCRIPT_DIR/../hooks.log"

    # Apply chezmoi changes first
    print_cmd_to_user "chezmoi apply --force"
    chezmoi apply --force

    # Check which types of files have changed
    local has_python_changes=false
    local has_lua_changes=false
    local has_bash_changes=false

    if has_changes_matching "$PYTHON_PATTERN"; then
        has_python_changes=true
    fi
    if has_changes_matching "$LUA_PATTERN"; then
        has_lua_changes=true
    fi
    if has_changes_matching "$BASH_PATTERN"; then
        has_bash_changes=true
    fi

    # Collect errors
    local errors=""
    local output

    # Run Lua linters and tests if Lua files changed
    if [ "$has_lua_changes" = true ]; then
        print_cmd_to_user "make lint-llscheck"
        if ! output=$(make lint-llscheck 2>&1); then
            errors+="make lint-llscheck FAILED:\n$output\n\n"
        fi

        print_cmd_to_user "make lint-luacheck"
        if ! output=$(make lint-luacheck 2>&1); then
            errors+="make lint-luacheck FAILED:\n$output\n\n"
        fi

        # Run nvim tests - can hang after completion, so use short timeout
        print_cmd_to_user "make test-nvim"
        if ! output=$(timeout 30 make test-nvim 2>&1); then
            local exit_code=$?
            # Only report if it's not just the timeout killing hanging nvim
            if [ $exit_code -ne 124 ]; then
                errors+="make test-nvim FAILED:\n$output\n\n"
            else
                # Timeout occurred - check if tests passed before timeout
                if ! echo "$output" | grep -q "0 failures"; then
                    errors+="make test-nvim FAILED (or hung before completing):\n$output\n\n"
                fi
            fi
        fi
    fi

    # Run Python linters and tests if Python files changed
    if [ "$has_python_changes" = true ]; then
        print_cmd_to_user "make lint-python"
        if ! output=$(make lint-python 2>&1); then
            errors+="make lint-python FAILED:\n$output\n\n"
        fi

        # Run python tests (can take 60+ seconds)
        print_cmd_to_user "make test-python"
        if ! output=$(timeout 120 make test-python 2>&1); then
            local exit_code=$?
            if [ $exit_code -eq 124 ]; then
                errors+="make test-python TIMED OUT after 120 seconds\n\n"
            else
                errors+="make test-python FAILED:\n$output\n\n"
            fi
        fi
    fi

    # Run bash tests if bash files changed
    if [ "$has_bash_changes" = true ]; then
        print_cmd_to_user "make test-bash"
        if ! output=$(make test-bash 2>&1); then
            errors+="make test-bash FAILED:\n$output\n\n"
        fi
    fi

    # Calculate elapsed time
    local end_time elapsed_seconds
    end_time=$(date +%s)
    elapsed_seconds=$((end_time - start_time))

    # If any errors occurred, block and report
    if [ -n "$errors" ]; then
        send_notification "false" "$elapsed_seconds" "$errors"
        echo -e "$errors" >&2
        return 2 # Exit code 2 blocks Claude and shows stderr
    fi

    # Check if there are any uncommitted changes
    if get_changed_files | grep -q .; then
        # Changes exist and all checks passed - request commit
        send_notification "true" "$elapsed_seconds" ""
        echo "All checks passed. Please use the /commit skill to commit your changes." >&2
        return 2
    fi

    send_notification "true" "$elapsed_seconds" ""
    return 0
}

run "$@"
