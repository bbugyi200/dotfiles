#!/bin/bash

# Directory containing this script (the .claude/hooks directory)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$(dirname "$SCRIPT_DIR")")"

# File patterns for conditional execution
PYTHON_PATTERN='^home/lib/.*\.py$'
LUA_PATTERN='^(home/dot_config/nvim|tests/nvim|home/lib)/.*\.lua$'
BASH_PATTERN='^(home/lib/bugyi\.sh|tests/bash/bugyi_test\.sh)$'
MD_PATTERN='\.md$'

# Session-unique marker file to avoid duplicate commit prompts
if [ -n "$TMUX_PANE" ]; then
    TMUX_PANE_ID="${TMUX_PANE//[%]/}"
else
    TMUX_PANE_ID="default"
fi
STORED_DIFF_FILE="/tmp/chez_stop_hook_diff_${TMUX_PANE_ID}"

# Get list of uncommitted changed files (modified + untracked)
function get_changed_files() {
    {
        git diff --name-only HEAD 2>/dev/null
        git ls-files --others --exclude-standard 2>/dev/null
    } | sort -u
}

# Check if any changed files match a pattern (reads from cached $CHANGED_FILES)
function has_changes_matching() {
    local pattern="$1"
    echo "$CHANGED_FILES" | grep -qE "$pattern"
}

# Print the command we are about to run.
function print_cmd_to_user() {
    local group="$1"
    local cmd="$2"
    echo "[chez_stop_hook:${group}] Running \`$cmd\`..."
}

# Send Mac notification for failures
function send_failure_notification() {
    local errors="$1"
    local prefix="\[chez]"
    local window
    if [[ -n "$TMUX_PANE" ]]; then
        window=$(tmux display-message -t "$TMUX_PANE" -p '#W' 2>/dev/null)
        if [[ -n "$window" ]]; then
            prefix="\[chez#${window}]"
        fi
    fi

    terminal-notifier -title "${prefix} Stop Hook - FAILED" -message "$errors"
}

# Run quality checks conditionally based on changed files
function run() {
    cd "$PROJECT_DIR" || return 1

    # If marker file exists from previous commit prompt, skip all checks
    if [ -f "$STORED_DIFF_FILE" ]; then
        rm -f "$STORED_DIFF_FILE"
        return 0
    fi

    # Log that this hook ran
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] chez_stop_hook ran" >>"$SCRIPT_DIR/../hooks.log"

    # Apply chezmoi changes first
    echo "[chez_stop_hook] Running \`chezmoi apply --force\`..."
    chezmoi apply --force

    # Cache changed files once (eliminates redundant git calls)
    CHANGED_FILES="$(get_changed_files)"

    # Check which types of files have changed
    local has_python_changes=false
    local has_lua_changes=false
    local has_bash_changes=false
    local has_md_changes=false

    if has_changes_matching "$PYTHON_PATTERN"; then
        has_python_changes=true
    fi
    if has_changes_matching "$LUA_PATTERN"; then
        has_lua_changes=true
    fi
    if has_changes_matching "$BASH_PATTERN"; then
        has_bash_changes=true
    fi
    if has_changes_matching "$MD_PATTERN"; then
        has_md_changes=true
    fi

    # Create temp directory for parallel job output
    local tmpdir
    tmpdir=$(mktemp -d)
    trap 'rm -rf "$tmpdir"' RETURN

    local pids=()

    # Run Lua linters and tests if Lua files changed
    if [ "$has_lua_changes" = true ]; then
        (
            local errors=""
            local output

            # Run lint-llscheck and lint-luacheck in parallel
            local lua_lint_pids=()

            print_cmd_to_user "lua" "make lint-llscheck"
            (
                if ! output=$(make lint-llscheck 2>&1); then
                    echo "make lint-llscheck FAILED:\n$output\n\n" >"$tmpdir/lua_llscheck_errors"
                fi
            ) &
            lua_lint_pids+=($!)

            print_cmd_to_user "lua" "make lint-luacheck"
            (
                if ! output=$(make lint-luacheck 2>&1); then
                    echo "make lint-luacheck FAILED:\n$output\n\n" >"$tmpdir/lua_luacheck_errors"
                fi
            ) &
            lua_lint_pids+=($!)

            # Wait for both linters to finish
            for pid in "${lua_lint_pids[@]}"; do
                wait "$pid"
            done

            # Collect linter errors
            for f in "$tmpdir"/lua_llscheck_errors "$tmpdir"/lua_luacheck_errors; do
                if [ -f "$f" ]; then
                    errors+="$(cat "$f")"
                fi
            done

            # Run nvim tests sequentially after linters
            print_cmd_to_user "lua" "make test-nvim"
            if ! output=$(timeout 30 make test-nvim 2>&1); then
                local exit_code=$?
                # Only report if it's not just the timeout killing hanging nvim
                if [ $exit_code -ne 124 ]; then
                    errors+="make test-nvim FAILED:\n$output\n\n"
                else
                    # Timeout occurred - check if tests passed before timeout
                    if ! echo "$output" | grep -q "0 failures"; then
                        errors+="make test-nvim FAILED (or hung before completing):\n$output\n\n"
                    fi
                fi
            fi

            if [ -n "$errors" ]; then
                printf '%s' "$errors" >"$tmpdir/lua_errors"
            fi
        ) &
        pids+=($!)
    fi

    # Run Python linters and tests if Python files changed
    if [ "$has_python_changes" = true ]; then
        (
            local errors=""
            local output

            print_cmd_to_user "python" "make lint-python"
            if ! output=$(make lint-python 2>&1); then
                errors+="make lint-python FAILED:\n$output\n\n"
            fi

            # Run python tests (can take 60+ seconds)
            print_cmd_to_user "python" "make test-python"
            if ! output=$(timeout 120 make test-python 2>&1); then
                local exit_code=$?
                if [ $exit_code -eq 124 ]; then
                    errors+="make test-python TIMED OUT after 120 seconds\n\n"
                else
                    errors+="make test-python FAILED:\n$output\n\n"
                fi
            fi

            if [ -n "$errors" ]; then
                printf '%s' "$errors" >"$tmpdir/python_errors"
            fi
        ) &
        pids+=($!)
    fi

    # Run bash tests if bash files changed
    if [ "$has_bash_changes" = true ]; then
        (
            local errors=""
            local output

            print_cmd_to_user "bash" "make test-bash"
            if ! output=$(make test-bash 2>&1); then
                errors+="make test-bash FAILED:\n$output\n\n"
            fi

            if [ -n "$errors" ]; then
                printf '%s' "$errors" >"$tmpdir/bash_errors"
            fi
        ) &
        pids+=($!)
    fi

    # Run markdown linter if markdown files changed
    if [ "$has_md_changes" = true ]; then
        (
            local errors=""
            local output

            print_cmd_to_user "md" "make lint-md"
            if ! output=$(make lint-md 2>&1); then
                errors+="make lint-md FAILED:\n$output\n\n"
            fi

            if [ -n "$errors" ]; then
                printf '%s' "$errors" >"$tmpdir/md_errors"
            fi
        ) &
        pids+=($!)
    fi

    # Wait for all background jobs to complete
    for pid in "${pids[@]}"; do
        wait "$pid"
    done

    # Collect errors from all groups
    local errors=""
    for f in "$tmpdir"/lua_errors "$tmpdir"/python_errors "$tmpdir"/bash_errors "$tmpdir"/md_errors; do
        if [ -f "$f" ]; then
            errors+="$(cat "$f")"
        fi
    done

    # If any errors occurred, block and report
    if [ -n "$errors" ]; then
        send_failure_notification "$errors"
        echo -e "$errors" >&2
        return 2 # Exit code 2 blocks Claude and shows stderr
    fi

    # Check if there are any uncommitted changes (uses cached file list)
    if echo "$CHANGED_FILES" | grep -q .; then
        # Create marker file and request commit
        touch "$STORED_DIFF_FILE"
        echo "All checks passed. If you made any file changes (which includes bead changes), please use your /commit skill to commit them now." >&2
        return 2
    fi

    return 0
}

run "$@"
