#!/bin/bash

# Directory containing this script (the .claude/hooks directory)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$(dirname "$SCRIPT_DIR")")"

# File patterns for conditional execution
PYTHON_PATTERN='^home/lib/.*\.py$'
LUA_PATTERN='^(home/dot_config/nvim|tests/nvim|home/lib)/.*\.lua$'
BASH_PATTERN='^(home/lib/bugyi\.sh|tests/bash/bugyi_test\.sh)$'

# Session-unique file for storing diff to avoid duplicate commit prompts
if [ -n "$TMUX_PANE" ]; then
    TMUX_PANE_ID="${TMUX_PANE//[%]/}"
else
    TMUX_PANE_ID="default"
fi
STORED_DIFF_FILE="/tmp/chez_stop_hook_diff_${TMUX_PANE_ID}"

# Get list of uncommitted changed files (modified + untracked)
function get_changed_files() {
    {
        git diff --name-only HEAD 2>/dev/null
        git ls-files --others --exclude-standard 2>/dev/null
    } | sort -u
}

# Check if any changed files match a pattern
function has_changes_matching() {
    local pattern="$1"
    get_changed_files | grep -qE "$pattern"
}

# Get current diff (tracked changes + list of untracked files)
function get_current_diff() {
    {
        git diff HEAD 2>/dev/null
        echo "---UNTRACKED---"
        git ls-files --others --exclude-standard 2>/dev/null
    }
}

# Print the command we are about to run.
function print_cmd_to_user() {
    local cmd="$1"
    shift
    echo "[chez_stop_hook] Running \`$cmd\`..."
}

# Send Mac notification for failures
function send_failure_notification() {
    local errors="$1"
    local prefix="\[chez]"
    local window
    if [[ -n "$TMUX_PANE" ]]; then
        window=$(tmux display-message -t "$TMUX_PANE" -p '#W' 2>/dev/null)
        if [[ -n "$window" ]]; then
            prefix="\[chez#${window}]"
        fi
    fi

    terminal-notifier -title "${prefix} Stop Hook - FAILED" -message "$errors"
}

# Run quality checks conditionally based on changed files
function run() {
    cd "$PROJECT_DIR" || return 1

    # Log that this hook ran
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] chez_stop_hook ran" >>"$SCRIPT_DIR/../hooks.log"

    # Apply chezmoi changes first
    print_cmd_to_user "chezmoi apply --force"
    chezmoi apply --force

    # Check which types of files have changed
    local has_python_changes=false
    local has_lua_changes=false
    local has_bash_changes=false

    if has_changes_matching "$PYTHON_PATTERN"; then
        has_python_changes=true
    fi
    if has_changes_matching "$LUA_PATTERN"; then
        has_lua_changes=true
    fi
    if has_changes_matching "$BASH_PATTERN"; then
        has_bash_changes=true
    fi

    # Collect errors
    local errors=""
    local output

    # Run Lua linters and tests if Lua files changed
    if [ "$has_lua_changes" = true ]; then
        print_cmd_to_user "make lint-llscheck"
        if ! output=$(make lint-llscheck 2>&1); then
            errors+="make lint-llscheck FAILED:\n$output\n\n"
        fi

        print_cmd_to_user "make lint-luacheck"
        if ! output=$(make lint-luacheck 2>&1); then
            errors+="make lint-luacheck FAILED:\n$output\n\n"
        fi

        # Run nvim tests - can hang after completion, so use short timeout
        print_cmd_to_user "make test-nvim"
        if ! output=$(timeout 30 make test-nvim 2>&1); then
            local exit_code=$?
            # Only report if it's not just the timeout killing hanging nvim
            if [ $exit_code -ne 124 ]; then
                errors+="make test-nvim FAILED:\n$output\n\n"
            else
                # Timeout occurred - check if tests passed before timeout
                if ! echo "$output" | grep -q "0 failures"; then
                    errors+="make test-nvim FAILED (or hung before completing):\n$output\n\n"
                fi
            fi
        fi
    fi

    # Run Python linters and tests if Python files changed
    if [ "$has_python_changes" = true ]; then
        print_cmd_to_user "make lint-python"
        if ! output=$(make lint-python 2>&1); then
            errors+="make lint-python FAILED:\n$output\n\n"
        fi

        # Run python tests (can take 60+ seconds)
        print_cmd_to_user "make test-python"
        if ! output=$(timeout 120 make test-python 2>&1); then
            local exit_code=$?
            if [ $exit_code -eq 124 ]; then
                errors+="make test-python TIMED OUT after 120 seconds\n\n"
            else
                errors+="make test-python FAILED:\n$output\n\n"
            fi
        fi
    fi

    # Run bash tests if bash files changed
    if [ "$has_bash_changes" = true ]; then
        print_cmd_to_user "make test-bash"
        if ! output=$(make test-bash 2>&1); then
            errors+="make test-bash FAILED:\n$output\n\n"
        fi
    fi

    # If any errors occurred, block and report
    if [ -n "$errors" ]; then
        send_failure_notification "$errors"
        echo -e "$errors" >&2
        return 2 # Exit code 2 blocks Claude and shows stderr
    fi

    # Check if there are any uncommitted changes
    if get_changed_files | grep -q .; then
        # Get current state
        local current_diff
        current_diff=$(get_current_diff)

        # Check if we've already seen this exact diff
        if [ -f "$STORED_DIFF_FILE" ]; then
            local stored_diff
            stored_diff=$(cat "$STORED_DIFF_FILE")

            if [ "$current_diff" = "$stored_diff" ]; then
                # Same changes as before - skip commit prompt once, then delete
                rm -f "$STORED_DIFF_FILE"
                return 0
            fi
        fi

        # Store current diff and request commit
        echo "$current_diff" >"$STORED_DIFF_FILE"
        echo "All checks passed. If you made any file changes, please use your /commit skill to commit them now." >&2
        return 2
    fi

    return 0
}

run "$@"
